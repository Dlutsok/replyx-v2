
# Проверяем, что TAG установлен и не равен 'latest'
# Используйте: export TAG=v1.0.0 перед запуском

services:
  # Frontend Next.js application
  frontend:
    image: ghcr.io/dlutsok/replyx-frontend:${TAG:-latest}
    container_name: replyx-frontend
    
    # Resource limits
    mem_limit: 512m
    memswap_limit: 512m
    cpus: "0.5"
    
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=production
      - NEXT_PUBLIC_API_URL=https://replyx.ru
      - NEXT_PUBLIC_FRONTEND_URL=https://replyx.ru
      - NEXT_TELEMETRY_DISABLED=1
    depends_on:
      - backend
    restart: unless-stopped
    networks:
      - replyx-network
    
    healthcheck:
      test: ["CMD", "wget", "-qO-", "http://localhost:3000/"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

  # Backend FastAPI application
  backend:
    image: ghcr.io/dlutsok/replyx-backend:${TAG:-latest}
    container_name: replyx-backend
    
    # Resource limits
    mem_limit: 1024m
    memswap_limit: 1024m
    cpus: "1.0"
    
    ports:
      - "8000:8000"
    env_file:
      - .env.production
    environment:
      - REDIS_URL=redis://:${REDIS_PASSWORD}@redis:6379/0
      - SKIP_PIP_INSTALL=1
      - UVICORN_WORKERS=4  # Multi-worker for API performance
      - ENABLE_WS_BRIDGE=false  # Backend only publishes, doesn't subscribe
    depends_on:
      - redis
    volumes:
      - ./ssl:/app/ssl
      - uploads-data:/app/uploads
    restart: unless-stopped
    networks:
      - replyx-network
    
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/docs"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

  # WebSocket Gateway - separate service for stable WebSocket connections
  ws-gateway:
    image: ghcr.io/dlutsok/replyx-backend:${TAG:-latest}
    container_name: replyx-ws-gateway
    
    # Resource limits optimized for WebSocket connections
    mem_limit: 768m
    memswap_limit: 768m
    cpus: "0.75"
    
    ports:
      - "8001:8001"
    env_file:
      - .env.production
    environment:
      - REDIS_URL=redis://:${REDIS_PASSWORD}@redis:6379/0
      - SKIP_PIP_INSTALL=1
      - UVICORN_WORKERS=1  # Single worker for WebSocket state consistency
      - UVICORN_PORT=8001
      - SERVICE_MODE=websocket  # Flag to indicate WebSocket-only mode
      - ENABLE_WS_BRIDGE=true  # Enable Redis Pub/Sub subscriber for real-time
    depends_on:
      - redis
    # Use same main.py but with different port
    command: ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8001", "--workers", "1"]
    volumes:
      - ./ssl:/app/ssl
      - uploads-data:/app/uploads
    restart: unless-stopped
    networks:
      - replyx-network
    
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8001/docs"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

  # Workers Node.js for Telegram bots
  workers:
    image: ghcr.io/dlutsok/replyx-workers:${TAG:-latest}
    container_name: replyx-workers
    
    # Resource limits
    mem_limit: 768m
    memswap_limit: 768m
    cpus: "0.75"
    
    ports:
      - "8443:8443"  # Telegram webhook port
      - "3002:3002"  # Health check port
    env_file:
      - .env.production
    environment:
      - REDIS_URL=redis://:${REDIS_PASSWORD}@redis:6379/0
    depends_on:
      - backend
      - redis
    volumes:
      - ./ssl:/app/ssl
    restart: unless-stopped
    networks:
      - replyx-network
    
    healthcheck:
      test: ["CMD", "curl", "-fsS", "http://localhost:3002/health"]
      interval: 15s
      timeout: 3s
      retries: 6
      start_period: 40s

  # Redis cache
  redis:
    image: redis:7-alpine
    container_name: replyx-redis
    
    # Resource limits
    mem_limit: 512m
    memswap_limit: 512m
    cpus: "0.25"
    
    ports:
      - "6379:6379"
    env_file:
      - .env.production
    command: >
      sh -c '
        if [ -n "$$REDIS_PASSWORD" ]; then
          redis-server --requirepass "$$REDIS_PASSWORD" --appendonly yes --maxmemory 512mb --maxmemory-policy allkeys-lru
        else
          redis-server --appendonly yes --maxmemory 512mb --maxmemory-policy allkeys-lru
        fi
      '
    volumes:
      - redis-data:/data
    restart: unless-stopped
    networks:
      - replyx-network
    
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 3s
      retries: 3

  # Nginx reverse proxy
  nginx:
    image: nginx:alpine
    container_name: replyx-nginx
    
    # Resource limits
    mem_limit: 256m
    memswap_limit: 256m
    cpus: "0.25"
    
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf
      - /etc/letsencrypt:/etc/letsencrypt:ro
      - ./nginx/static:/var/www/static
    depends_on:
      - frontend
      - backend
      - ws-gateway
    restart: unless-stopped
    networks:
      - replyx-network
      - public
    
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost/health"]
      interval: 30s
      timeout: 5s
      retries: 3

volumes:
  redis-data:
    driver: local
  uploads-data:
    driver: local

networks:
  # Public network for nginx external access
  public:
    driver: bridge
    name: replyx_public
    ipam:
      config:
        - subnet: 172.20.0.0/24
  
  # Internal network for services communication
  replyx-network:
    driver: bridge
    name: replyx_internal
    ipam:
      config:
        - subnet: 172.21.0.0/24
