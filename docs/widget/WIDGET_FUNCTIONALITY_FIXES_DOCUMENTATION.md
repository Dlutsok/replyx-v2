# Виджет чата - Исправления функциональности

## Обзор проблем

Были выявлены и исправлены две критические проблемы в работе виджета чата:

1. **Постоянное отображение приветственного сообщения** - приветственное сообщение появлялось каждый раз при открытии виджета, даже когда существовала история переписки
2. **Необходимость двойной отправки сообщений** - пользователям требовалось отправлять сообщение дважды, чтобы получить ответ от AI

## Техническая архитектура исправлений

### 1. Управление состоянием диалога

Добавлены новые переменные состояния в `/frontend/pages/chat-iframe.js`:

```javascript
const [dialogLoaded, setDialogLoaded] = useState(false);
const [creatingDialog, setCreatingDialog] = useState(false);
```

**Назначение:**
- `dialogLoaded` - отслеживает, когда диалог фактически загружен из API
- `creatingDialog` - предотвращает одновременное создание нескольких диалогов

### 2. Исправление логики приветственного сообщения

**Проблема:** Приветственное сообщение показывалось всякий раз, когда `filteredMessages.length === 0`, что происходило во время временных состояний загрузки.

**Решение:** Изменена логика отображения в строках 1511-1532:

```javascript
// Показываем приветственное сообщение только если диалог загружен и пуст
if (filteredMessages.length === 0 && dialogLoaded) {
  return (
    <div key="welcome_virtual">
      <div className="message-bubble assistant-message">
        <div className="message-content">{welcomeMessage}</div>
      </div>
    </div>
  );
}
```

**Результат:** Приветственное сообщение теперь отображается только когда диалог действительно пуст, а не во время загрузки.

### 3. Предотвращение двойной отправки сообщений

**Проблема:** Гонки (race conditions) в создании диалога позволяли множественные одновременные запросы.

**Решение:** Добавлена защита от состояния загрузки в функции `handleSend`:

```javascript
const handleSend = async () => {
  if (inputText.trim() === '' || loading || creatingDialog) return;
  
  // Дополнительная логика предотвращения множественных запросов
};
```

**Результат:** Предотвращены множественные одновременные создания диалогов и отправки сообщений.

### 4. Синхронизация состояния при загрузке

**Улучшения в функциях загрузки:**

Все функции загрузки сообщений теперь устанавливают `dialogLoaded: true`:

```javascript
const fetchDialogMessages = async (dialogId) => {
  try {
    // ... логика загрузки ...
    setDialogLoaded(true);
  } catch (error) {
    // ... обработка ошибок ...
    setDialogLoaded(false);
  }
};
```

### 5. Восстановление состояния при WebSocket переподключении

Добавлена логика восстановления в обработчике `onopen`:

```javascript
socket.onopen = () => {
  console.log('WebSocket connected');
  setIsConnected(true);
  
  if (currentDialogId) {
    // Восстанавливаем состояние после переподключения
    fetchDialogMessages(currentDialogId);
  }
};
```

## Затронутые файлы

### 1. `/frontend/pages/chat-iframe.js` (основной файл)
- **Новые переменные состояния:** `dialogLoaded`, `creatingDialog`
- **Обновленная логика приветственного сообщения:** строки 1511-1532
- **Улучшенная функция отправки сообщений:** `handleSend`
- **Обновленные функции загрузки:** `fetchDialogMessages`, `fetchAssistantDialog`
- **Восстановление состояния WebSocket:** обработчик `onopen`

### 2. `/frontend/public/widget.js`
- Основной загрузчик виджета (без изменений, но анализировался для понимания архитектуры)

### 3. `/backend/api/site.py`
- API endpoints для виджета (без изменений, но анализировался для понимания потока данных)

## Workflow исправленной функциональности

### Сценарий 1: Первое открытие виджета
1. Виджет инициализируется с `dialogLoaded: false`
2. Приветственное сообщение НЕ показывается (так как диалог не загружен)
3. После полной загрузки: `dialogLoaded: true`
4. Если сообщений нет, показывается приветственное сообщение

### Сценарий 2: Открытие виджета с существующей историей
1. Виджет инициализируется и загружает существующий диалог
2. `setDialogLoaded(true)` устанавливается после загрузки сообщений
3. Приветственное сообщение НЕ показывается (есть история сообщений)
4. Отображается полная история переписки

### Сценарий 3: Отправка сообщения
1. Пользователь вводит текст и нажимает "Отправить"
2. Проверка: `if (inputText.trim() === '' || loading || creatingDialog) return;`
3. Если все проверки пройдены, сообщение отправляется ОДИН раз
4. Состояния загрузки предотвращают повторные отправки

## Преимущества реализации

1. **Надежность:** Устранены race conditions при создании диалогов
2. **Пользовательский опыт:** Приветственное сообщение не перекрывает историю
3. **Производительность:** Предотвращены избыточные API запросы
4. **Стабильность:** Улучшена синхронизация состояния при WebSocket переподключениях

## Мониторинг и отладка

Добавлено расширенное логирование для отслеживания состояний:

```javascript
console.log('Dialog loaded state:', dialogLoaded);
console.log('Creating dialog state:', creatingDialog);
console.log('Filtered messages count:', filteredMessages.length);
```

## Совместимость

Все исправления обратно совместимы и не затрагивают существующие API endpoints или настройки виджета.

---

**Дата исправлений:** 2 сентября 2025  
**Затронутые компоненты:** Frontend Widget, WebSocket, State Management  
**Статус:** Протестировано и внедрено