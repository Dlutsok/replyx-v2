<?xml version="1.0" encoding="utf-8"?><testsuites name="pytest tests"><testsuite name="pytest" errors="0" failures="10" skipped="0" tests="34" time="1.087" timestamp="2025-09-06T11:27:51.272144+03:00" hostname="MacBook-Pro-Dan.local"><testcase classname="tests.test_websocket_critical_fixes.TestWebSocketCriticalFixes" name="test_widget_endpoint_uses_correct_connection_pool" time="0.028"><failure message="KeyError: 1">self = &lt;test_websocket_critical_fixes.TestWebSocketCriticalFixes object at 0x10ae73390&gt;

    @pytest.mark.asyncio
    async def test_widget_endpoint_uses_correct_connection_pool(self):
        """КРИТИЧНО: Widget endpoint ДОЛЖЕН использовать ws_connections, НЕ ws_site_connections"""
        # Мокаем зависимости
        mock_websocket = MagicMock(spec=WebSocket)
        mock_websocket.accept = AsyncMock()
        mock_websocket.close = AsyncMock()
    
        mock_db = MagicMock()
        mock_assistant = MagicMock()
        mock_assistant.id = 1
        mock_db.query().filter().first.return_value = mock_assistant
    
        dialog_id = 1
        assistant_id = 1
    
        # Мокаем внутренние функции для контроля
        with patch('services.websocket_manager._register_connection', new_callable=AsyncMock) as mock_register, \
             patch('services.websocket_manager._receive_loop', new_callable=AsyncMock), \
             patch('services.websocket_manager._heartbeat_loop', new_callable=AsyncMock), \
             patch('services.websocket_manager._unregister_connection', new_callable=AsyncMock) as mock_unregister, \
             patch('asyncio.wait', new_callable=AsyncMock):
    
            mock_register.return_value = True
    
            # Вызов widget endpoint
&gt;           await widget_dialog_websocket_endpoint(mock_websocket, dialog_id, assistant_id, mock_db)

tests/test_websocket_critical_fixes.py:56: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

websocket = &lt;MagicMock spec='WebSocket' id='4480884688'&gt;, dialog_id = 1
assistant_id = 1, db = &lt;MagicMock id='4480885696'&gt;

    async def widget_dialog_websocket_endpoint(websocket: WebSocket, dialog_id: int, assistant_id: int, db: Session = None):
        """WebSocket endpoint для widget диалогов"""
        logger.info(f"Widget WebSocket connection attempt for dialog {dialog_id}, assistant {assistant_id}")
    
        await websocket.accept()  # Accept до проверок
    
        # Rate limiting проверка после accept() с защитой от IP spoofing
        client_ip = _extract_client_ip(websocket)
        if not _check_rate_limit(client_ip):
            await websocket.close(code=WSCloseCodes.RATE_LIMITED, reason="Too many connections")
            return
    
        # Проверяем, что ассистент существует
        assistant = db.query(models.Assistant).filter(models.Assistant.id == assistant_id).first()
        if not assistant:
            logger.error(f"Widget assistant {assistant_id} not found")
            await websocket.close(code=WSCloseCodes.NOT_FOUND, reason="Assistant not found")
            return
    
        logger.info(f"Widget WebSocket accepted for dialog {dialog_id}")
    
        ok = await _register_connection(ws_connections, ws_meta, dialog_id, websocket)
        if not ok:
            return
    
&gt;       logger.info(f"Total widget connections for dialog {dialog_id}: {len(ws_connections[dialog_id])}")
                                                                            ^^^^^^^^^^^^^^^^^^^^^^^^^
E       KeyError: 1

services/websocket_manager.py:462: KeyError</failure></testcase><testcase classname="tests.test_websocket_critical_fixes.TestWebSocketCriticalFixes" name="test_site_endpoint_uses_correct_connection_pool" time="0.011"><failure message="assert 0 == 1&#10; +  where 0 = len([])">self = &lt;test_websocket_critical_fixes.TestWebSocketCriticalFixes object at 0x10ae734d0&gt;

    @pytest.mark.asyncio
    async def test_site_endpoint_uses_correct_connection_pool(self):
        """Site endpoint должен использовать ws_site_connections"""
        mock_websocket = MagicMock(spec=WebSocket)
        mock_websocket.accept = AsyncMock()
    
        mock_db = MagicMock()
        site_token = "test_token"
        dialog_id = 1
    
        with patch('services.websocket_manager.get_current_site_user_simple') as mock_auth, \
             patch('services.websocket_manager._register_connection', new_callable=AsyncMock) as mock_register, \
             patch('services.websocket_manager._receive_loop', new_callable=AsyncMock), \
             patch('services.websocket_manager._heartbeat_loop', new_callable=AsyncMock), \
             patch('services.websocket_manager._unregister_connection', new_callable=AsyncMock), \
             patch('asyncio.wait', new_callable=AsyncMock):
    
            mock_auth.return_value = MagicMock()  # Успешная авторизация
            mock_register.return_value = True
    
            await site_dialog_websocket_endpoint(mock_websocket, dialog_id, site_token, mock_db)
    
            # Проверяем использование правильного пула
            register_calls = mock_register.call_args_list
&gt;           assert len(register_calls) == 1
E           assert 0 == 1
E            +  where 0 = len([])

tests/test_websocket_critical_fixes.py:91: AssertionError</failure></testcase><testcase classname="tests.test_websocket_critical_fixes.TestWebSocketCriticalFixes" name="test_message_routing_widget_connections" time="0.001" /><testcase classname="tests.test_websocket_critical_fixes.TestWebSocketCriticalFixes" name="test_message_routing_site_connections" time="0.001" /><testcase classname="tests.test_websocket_critical_fixes.TestWebSocketCriticalFixes" name="test_no_cross_pool_contamination" time="0.001" /><testcase classname="tests.test_websocket_critical_fixes" name="test_no_duplicate_websocket_endpoints" time="0.287" /><testcase classname="tests.test_websocket_critical_fixes.TestWebSocketIntegration" name="test_widget_websocket_full_flow" time="0.001" /><testcase classname="tests.test_websocket_critical_fixes.TestWebSocketIntegration" name="test_site_websocket_full_flow" time="0.001" /><testcase classname="tests.test_websocket_critical_fixes.TestWebSocketLoad" name="test_multiple_concurrent_connections" time="0.001" /><testcase classname="tests.test_websocket_critical_fixes.TestWebSocketLoad" name="test_high_message_throughput" time="0.001" /><testcase classname="tests.test_websocket_integration.TestWebSocketCloseCodes" name="test_rate_limited_close_code" time="0.001" /><testcase classname="tests.test_websocket_integration.TestWebSocketCloseCodes" name="test_auth_failed_close_code" time="0.001" /><testcase classname="tests.test_websocket_integration.TestWebSocketCloseCodes" name="test_forbidden_domain_close_code" time="0.001" /><testcase classname="tests.test_websocket_integration.TestWebSocketCloseCodes" name="test_not_found_close_code" time="0.001" /><testcase classname="tests.test_websocket_integration.TestRateLimiting" name="test_rate_limit_allow_under_limit" time="0.001" /><testcase classname="tests.test_websocket_integration.TestRateLimiting" name="test_rate_limit_deny_over_limit" time="0.001" /><testcase classname="tests.test_websocket_integration.TestRateLimiting" name="test_rate_limit_window_cleanup" time="0.001" /><testcase classname="tests.test_websocket_integration.TestRateLimiting" name="test_rate_limit_no_ip" time="0.000" /><testcase classname="tests.test_websocket_integration.TestDomainValidation" name="test_normalize_host_from_origin" time="0.001" /><testcase classname="tests.test_websocket_integration.TestDomainValidation" name="test_domain_allowed_by_token_valid" time="0.001"><failure message="AttributeError: &lt;module 'services.websocket_manager' from '/Users/dan/Documents/chatAI/MVP 13/backend/services/websocket_manager.py'&gt; does not have the attribute 'jwt'">args = (&lt;test_websocket_integration.TestDomainValidation object at 0x10af04550&gt;,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py:1423: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py:1405: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:530: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py:1497: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0x10aebbbd0&gt;

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
&gt;           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: &lt;module 'services.websocket_manager' from '/Users/dan/Documents/chatAI/MVP 13/backend/services/websocket_manager.py'&gt; does not have the attribute 'jwt'

/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py:1467: AttributeError</failure></testcase><testcase classname="tests.test_websocket_integration.TestDomainValidation" name="test_domain_allowed_by_token_invalid" time="0.001"><failure message="AttributeError: &lt;module 'services.websocket_manager' from '/Users/dan/Documents/chatAI/MVP 13/backend/services/websocket_manager.py'&gt; does not have the attribute 'jwt'">args = (&lt;test_websocket_integration.TestDomainValidation object at 0x10aecdcd0&gt;,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py:1423: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py:1405: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:530: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py:1497: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0x10aebba10&gt;

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
&gt;           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: &lt;module 'services.websocket_manager' from '/Users/dan/Documents/chatAI/MVP 13/backend/services/websocket_manager.py'&gt; does not have the attribute 'jwt'

/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py:1467: AttributeError</failure></testcase><testcase classname="tests.test_websocket_integration.TestDomainValidation" name="test_domain_allowed_subdomain_support" time="0.001"><failure message="AttributeError: &lt;module 'services.websocket_manager' from '/Users/dan/Documents/chatAI/MVP 13/backend/services/websocket_manager.py'&gt; does not have the attribute 'jwt'">args = (&lt;test_websocket_integration.TestDomainValidation object at 0x10aecde00&gt;,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py:1423: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py:1405: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:530: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py:1497: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0x10aebb930&gt;

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
&gt;           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: &lt;module 'services.websocket_manager' from '/Users/dan/Documents/chatAI/MVP 13/backend/services/websocket_manager.py'&gt; does not have the attribute 'jwt'

/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py:1467: AttributeError</failure></testcase><testcase classname="tests.test_websocket_integration.TestMessageQueue" name="test_message_queue_creation" time="0.001" /><testcase classname="tests.test_websocket_integration.TestMessageQueue" name="test_send_message_with_ack" time="0.001" /><testcase classname="tests.test_websocket_integration.TestMessageQueue" name="test_handle_ack" time="0.001" /><testcase classname="tests.test_websocket_integration.TestMessageQueue" name="test_handle_ack_wrong_websocket" time="0.001" /><testcase classname="tests.test_websocket_integration.TestMessageQueue" name="test_is_message_processed_deduplication" time="0.000" /><testcase classname="tests.test_websocket_integration.TestConcurrentOperations" name="test_concurrent_push_messages" time="0.002"><failure message="assert 0 == 10&#10; +  where 0 = len([])&#10; +    where [] = &lt;test_websocket_integration.MockWebSocket object at 0x10be6f490&gt;.messages_sent">self = &lt;test_websocket_integration.TestConcurrentOperations object at 0x10af04910&gt;

    @pytest.mark.asyncio
    async def test_concurrent_push_messages(self):
        """Тест concurrent отправки сообщений"""
        dialog_id = 1
    
        # Создаем несколько mock WebSocket'ов
        mock_ws_list = [MockWebSocket() for _ in range(5)]
        ws_connections[dialog_id] = set(mock_ws_list)
    
        # Отправляем сообщения конкурентно
        tasks = []
        for i in range(10):
            task = asyncio.create_task(
                push_dialog_message(dialog_id, {"id": i, "text": f"Message {i}"})
            )
            tasks.append(task)
    
        # Ждем завершения всех задач
        await asyncio.gather(*tasks)
    
        # Проверяем что все сообщения дошли до всех клиентов
        for mock_ws in mock_ws_list:
&gt;           assert len(mock_ws.messages_sent) == 10
E           assert 0 == 10
E            +  where 0 = len([])
E            +    where [] = &lt;test_websocket_integration.MockWebSocket object at 0x10be6f490&gt;.messages_sent

tests/test_websocket_integration.py:310: AssertionError</failure></testcase><testcase classname="tests.test_websocket_integration.TestConcurrentOperations" name="test_connection_cleanup_on_error" time="0.001"><failure message="assert &lt;test_websocket_integration.MockWebSocket object at 0x10bee2c60&gt; in set()">self = &lt;test_websocket_integration.TestConcurrentOperations object at 0x10af04a50&gt;

    @pytest.mark.asyncio
    async def test_connection_cleanup_on_error(self):
        """Тест очистки соединений при ошибках"""
        dialog_id = 1
    
        # Создаем mock WebSocket который будет выбрасывать ошибку при send_json
        error_ws = MockWebSocket()
        error_ws.send_json = AsyncMock(side_effect=Exception("Connection error"))
    
        good_ws = MockWebSocket()
    
        ws_connections[dialog_id] = {error_ws, good_ws}
    
        # Отправляем сообщение
        await push_dialog_message(dialog_id, {"text": "test"})
    
        # Проверяем что error_ws удален, а good_ws остался
        remaining_connections = ws_connections.get(dialog_id, set())
        assert error_ws not in remaining_connections
&gt;       assert good_ws in remaining_connections
E       assert &lt;test_websocket_integration.MockWebSocket object at 0x10bee2c60&gt; in set()

tests/test_websocket_integration.py:331: AssertionError</failure></testcase><testcase classname="tests.test_websocket_integration.TestConnectionStatistics" name="test_connection_stats_basic" time="0.001"><failure message="AssertionError: assert 'admin_dialogs' in {'connection_details': {'admin_connections': 0, 'admin_dialogs': 0, 'site_connections': 0, 'site_dialogs': 0}, 'message_queue': {'pending_messages': 0, 'processed_messages': 0, 'registered_websockets': 0, 'retry_ready': 0}, 'performance': {'cleanup_cycles': 0, 'dialog_locks': 1}, 'rate_limiting': {'rate_limit_per_ip': 100, 'rate_limit_window': 60, 'rate_limited_ips': 0, 'total_rate_limit_entries': 0}, ...}">self = &lt;test_websocket_integration.TestConnectionStatistics object at 0x10af04b90&gt;

    def test_connection_stats_basic(self):
        """Тест базовой статистики"""
        stats = get_connection_stats()
    
        assert "total_connections" in stats
&gt;       assert "admin_dialogs" in stats
E       AssertionError: assert 'admin_dialogs' in {'connection_details': {'admin_connections': 0, 'admin_dialogs': 0, 'site_connections': 0, 'site_dialogs': 0}, 'message_queue': {'pending_messages': 0, 'processed_messages': 0, 'registered_websockets': 0, 'retry_ready': 0}, 'performance': {'cleanup_cycles': 0, 'dialog_locks': 1}, 'rate_limiting': {'rate_limit_per_ip': 100, 'rate_limit_window': 60, 'rate_limited_ips': 0, 'total_rate_limit_entries': 0}, ...}

tests/test_websocket_integration.py:342: AssertionError</failure></testcase><testcase classname="tests.test_websocket_integration.TestConnectionStatistics" name="test_connection_stats_with_active_limits" time="0.001"><failure message="KeyError: 'rate_limited_ips'">self = &lt;test_websocket_integration.TestConnectionStatistics object at 0x10af04cd0&gt;

    def test_connection_stats_with_active_limits(self):
        """Тест статистики с активными rate limits"""
        # Добавляем активные rate limits
        current_time = time.time()
        _ws_rate_limits["10.0.0.1"] = [current_time]
        _ws_rate_limits["10.0.0.2"] = [current_time - WS_RATE_LIMIT_WINDOW - 1]  # Старая запись
    
        stats = get_connection_stats()
    
        # Должна быть только одна активная запись
&gt;       assert stats["rate_limited_ips"] == 1
               ^^^^^^^^^^^^^^^^^^^^^^^^^
E       KeyError: 'rate_limited_ips'

tests/test_websocket_integration.py:358: KeyError</failure></testcase><testcase classname="tests.test_websocket_integration.TestProductionEdgeCases" name="test_websocket_disconnect_during_message" time="0.001" /><testcase classname="tests.test_websocket_integration.TestProductionEdgeCases" name="test_memory_cleanup_large_rate_limits" time="0.001" /><testcase classname="tests.test_websocket_integration.TestProductionEdgeCases" name="test_high_concurrency_connections" time="0.012"><failure message="assert 0 == 1&#10; +  where 0 = len([])&#10; +    where [] = &lt;test_websocket_integration.MockWebSocket object at 0x10cb7c670&gt;.messages_sent">self = &lt;test_websocket_integration.TestProductionEdgeCases object at 0x10aece190&gt;

    @pytest.mark.asyncio
    async def test_high_concurrency_connections(self):
        """Тест высокой конкурентности подключений"""
        dialog_id = 1
    
        # Симулируем много одновременных подключений
        mock_ws_list = [MockWebSocket() for _ in range(100)]
    
        # Добавляем все сразу (имитация concurrent подключений)
        ws_connections[dialog_id] = set(mock_ws_list)
    
        # Отправляем сообщение всем
        await push_dialog_message(dialog_id, {"text": "broadcast test"})
    
        # Все должны получить сообщение
        for mock_ws in mock_ws_list:
&gt;           assert len(mock_ws.messages_sent) == 1
E           assert 0 == 1
E            +  where 0 = len([])
E            +    where [] = &lt;test_websocket_integration.MockWebSocket object at 0x10cb7c670&gt;.messages_sent

tests/test_websocket_integration.py:414: AssertionError</failure></testcase></testsuite></testsuites>