<?xml version="1.0" encoding="utf-8"?><testsuites name="pytest tests"><testsuite name="pytest" errors="0" failures="10" skipped="0" tests="37" time="1.408" timestamp="2025-09-06T11:38:47.355464+03:00" hostname="MacBook-Pro-Dan.local"><testcase classname="tests.test_integration_cross_channel.TestCrossChannelIntegration" name="test_complete_message_flow_admin_to_widget" time="0.023" /><testcase classname="tests.test_integration_cross_channel.TestCrossChannelIntegration" name="test_complete_message_flow_widget_to_admin" time="0.001" /><testcase classname="tests.test_integration_cross_channel.TestCrossChannelIntegration" name="test_ai_response_broadcast_to_all_channels" time="0.002" /><testcase classname="tests.test_integration_cross_channel.TestMultipleConnectionsIntegration" name="test_multiple_admin_panels_receive_messages" time="0.002" /><testcase classname="tests.test_integration_cross_channel.TestMultipleConnectionsIntegration" name="test_multiple_widgets_receive_operator_messages" time="0.002" /><testcase classname="tests.test_integration_cross_channel.TestHandoffEventsIntegration" name="test_handoff_started_event_broadcast" time="0.001" /><testcase classname="tests.test_integration_cross_channel.TestHandoffEventsIntegration" name="test_handoff_requested_event_broadcast" time="0.001" /><testcase classname="tests.test_integration_cross_channel.TestTypingIndicatorsIntegration" name="test_typing_indicators_widget_only" time="0.002" /><testcase classname="tests.test_integration_cross_channel.TestFailureRecoveryIntegration" name="test_partial_connection_failure" time="0.003"><failure message="AttributeError: 'list' object has no attribute 'discard'">dialog_id = 123
message = {'id': 456, 'sender': 'manager', 'text': 'Message with partial failure', 'timestamp': '2025-01-15T10:30:00Z'}

    async def push_dialog_message(dialog_id: int, message: dict):
        """Отправляет сообщение всем подключенным клиентам диалога (админ панель)"""
        async with await _get_dialog_lock(dialog_id):
            conns = ws_connections.get(dialog_id, set())
            logger.info(f"Push to ADMIN dialog {dialog_id}: {len(conns)} connections")
            logger.debug(f"Admin message: {message}")
    
            if not conns:
                logger.warning(f"No ADMIN WebSocket connections found for dialog {dialog_id}")
                logger.debug(f"Available ADMIN dialogs: {list(ws_connections.keys())}")
                return
    
            sent_count = 0
            # Создаем копию set для итерации, чтобы избежать изменений во время итерации
            for ws in conns.copy():
                try:
&gt;                   await ws.send_json(message)

services/websocket_manager.py:503: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;AsyncMock name='mock.send_json' id='4478618992'&gt;
args = ({'id': 456, 'sender': 'manager', 'text': 'Message with partial failure', 'timestamp': '2025-01-15T10:30:00Z'},)
kwargs = {}
_call = call({'id': 456, 'sender': 'manager', 'text': 'Message with partial failure', 'timestamp': '2025-01-15T10:30:00Z'})
effect = Exception('Connection closed')

    async def _execute_mock_call(self, /, *args, **kwargs):
        # This is nearly just like super(), except for special handling
        # of coroutines
    
        _call = _Call((args, kwargs), two=True)
        self.await_count += 1
        self.await_args = _call
        self.await_args_list.append(_call)
    
        effect = self.side_effect
        if effect is not None:
            if _is_exception(effect):
&gt;               raise effect
E               Exception: Connection closed

/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py:2321: Exception

During handling of the above exception, another exception occurred:

self = &lt;test_integration_cross_channel.TestFailureRecoveryIntegration object at 0x106f8a350&gt;

    @pytest.mark.asyncio
    async def test_partial_connection_failure(self):
        """Test behavior when some connections fail"""
        # Setup connections where one fails
        working_admin_ws = AsyncMock()
        failing_admin_ws = AsyncMock()
        failing_admin_ws.send_json.side_effect = Exception("Connection closed")
    
        working_widget_ws = AsyncMock()
    
        dialog_id = 123
        ws_connections[dialog_id] = [working_admin_ws, failing_admin_ws]
        ws_site_connections[dialog_id] = [working_widget_ws]
    
        message_data = {
            "id": 456,
            "sender": "manager",
            "text": "Message with partial failure",
            "timestamp": "2025-01-15T10:30:00Z"
        }
    
        # Should not raise exception despite one failing connection
&gt;       await push_dialog_message(dialog_id, message_data)

tests/test_integration_cross_channel.py:306: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
services/websocket_manager.py:509: in push_dialog_message
    await _drop_socket(ws_connections, ws_meta, dialog_id, ws, reason="Send failed")
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

bucket = {123: [&lt;AsyncMock id='4477227696'&gt;, &lt;AsyncMock id='4477231056'&gt;]}
meta_bucket = {}, dialog_id = 123, ws = &lt;AsyncMock id='4477231056'&gt;, code = 1001
reason = 'Send failed'

    async def _drop_socket(bucket: Dict[int, Set[WebSocket]], meta_bucket: Dict[int, Dict[WebSocket, Dict[str, float]]], dialog_id: int, ws: WebSocket, code=WSCloseCodes.GOING_AWAY, reason="Connection dropped"):
        """Безопасно удаляет сокет из всех структур данных"""
        global _total_connections
    
        conns = bucket.get(dialog_id, set())
        if ws in conns:
&gt;           conns.discard(ws)
            ^^^^^^^^^^^^^
E           AttributeError: 'list' object has no attribute 'discard'

services/websocket_manager.py:236: AttributeError</failure></testcase><testcase classname="tests.test_integration_cross_channel.TestFailureRecoveryIntegration" name="test_no_connections_graceful_handling" time="0.001" /><testcase classname="tests.test_integration_cross_channel.TestMessageFormatIntegration" name="test_direct_message_format" time="0.001" /><testcase classname="tests.test_integration_cross_channel.TestMessageFormatIntegration" name="test_wrapped_message_format" time="0.001" /><testcase classname="tests.test_integration_cross_channel.TestMessageFormatIntegration" name="test_system_event_format" time="0.002" /><testcase classname="tests.test_integration_cross_channel.TestPerformanceIntegration" name="test_high_throughput_cross_channel" time="0.014" /><testcase classname="tests.test_integration_cross_channel.TestPerformanceIntegration" name="test_concurrent_message_sending" time="0.003" /><testcase classname="tests.test_integration_realtime.TestRealTimeIntegration" name="test_complete_message_flow_admin_to_widget" time="0.002"><failure message="TypeError: Client.__init__() got an unexpected keyword argument 'app'">self = &lt;test_integration_realtime.TestRealTimeIntegration object at 0x10ac70550&gt;

    @pytest.mark.asyncio
    async def test_complete_message_flow_admin_to_widget(self):
        """Test complete message flow from admin API to widget WebSocket"""
    
        # Mock database
        with patch('database.get_db') as mock_get_db:
            mock_db = Mock()
            mock_get_db.return_value = mock_db
    
            # Mock dialog and message objects
            mock_dialog = Mock()
            mock_dialog.id = 123
            mock_dialog.handoff_status = 'none'
    
            mock_message = Mock()
            mock_message.id = 456
            mock_message.sender = 'manager'
            mock_message.text = 'Hello from admin'
            mock_message.timestamp.isoformat.return_value = '2025-01-15T10:30:00'
    
            mock_db.query.return_value.filter.return_value.first.return_value = mock_dialog
            mock_db.add = Mock()
            mock_db.commit = Mock()
            mock_db.refresh = Mock()
    
            # Mock WebSocket connections
            admin_ws = AsyncMock()
            widget_ws = AsyncMock()
            ws_connections[123] = [admin_ws]
            ws_site_connections[123] = [widget_ws]
    
            with patch('api.dialogs.models.DialogMessage', return_value=mock_message):
                with patch('core.auth.get_current_user', return_value=Mock()):
                    # Simulate API call
&gt;                   client = TestClient(app)
                             ^^^^^^^^^^^^^^^

tests/test_integration_realtime.py:60: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;starlette.testclient.TestClient object at 0x10b5356a0&gt;
app = &lt;fastapi.applications.FastAPI object at 0x10756a3c0&gt;
base_url = 'http://testserver', raise_server_exceptions = True, root_path = ''
backend = 'asyncio', backend_options = None, cookies = None
headers = {'user-agent': 'testclient'}, follow_redirects = True

    def __init__(
        self,
        app: ASGIApp,
        base_url: str = "http://testserver",
        raise_server_exceptions: bool = True,
        root_path: str = "",
        backend: typing.Literal["asyncio", "trio"] = "asyncio",
        backend_options: dict[str, typing.Any] | None = None,
        cookies: httpx._types.CookieTypes | None = None,
        headers: dict[str, str] | None = None,
        follow_redirects: bool = True,
    ) -&gt; None:
        self.async_backend = _AsyncBackend(
            backend=backend, backend_options=backend_options or {}
        )
        if _is_asgi3(app):
            asgi_app = app
        else:
            app = typing.cast(ASGI2App, app)  # type: ignore[assignment]
            asgi_app = _WrapASGI2(app)  # type: ignore[arg-type]
        self.app = asgi_app
        self.app_state: dict[str, typing.Any] = {}
        transport = _TestClientTransport(
            self.app,
            portal_factory=self._portal_factory,
            raise_server_exceptions=raise_server_exceptions,
            root_path=root_path,
            app_state=self.app_state,
        )
        if headers is None:
            headers = {}
        headers.setdefault("user-agent", "testclient")
&gt;       super().__init__(
            app=self.app,
            base_url=base_url,
            headers=headers,
            transport=transport,
            follow_redirects=follow_redirects,
            cookies=cookies,
        )
E       TypeError: Client.__init__() got an unexpected keyword argument 'app'

/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/starlette/testclient.py:429: TypeError</failure></testcase><testcase classname="tests.test_integration_realtime.TestRealTimeIntegration" name="test_widget_user_message_routing" time="0.002"><failure message="TypeError: Client.__init__() got an unexpected keyword argument 'app'">self = &lt;test_integration_realtime.TestRealTimeIntegration object at 0x10ac70410&gt;

    @pytest.mark.asyncio
    async def test_widget_user_message_routing(self):
        """Test that user messages from widget only go to admin WebSocket"""
    
        with patch('database.get_db') as mock_get_db:
            mock_db = Mock()
            mock_get_db.return_value = mock_db
    
            # Mock assistant and dialog
            mock_assistant = Mock()
            mock_assistant.user_id = 1
            mock_dialog = Mock()
            mock_dialog.id = 123
            mock_dialog.handoff_status = 'none'
    
            mock_message = Mock()
            mock_message.id = 789
            mock_message.sender = 'user'
            mock_message.text = 'Hello from widget user'
            mock_message.timestamp.isoformat.return_value = '2025-01-15T10:30:00'
    
            # Setup query chain for widget endpoint
            mock_db.query.return_value.filter.return_value.first.side_effect = [
                mock_assistant,  # First query for assistant
                mock_dialog      # Second query for dialog
            ]
            mock_db.add = Mock()
            mock_db.commit = Mock()
            mock_db.refresh = Mock()
    
            # Mock WebSocket connections
            admin_ws = AsyncMock()
            widget_ws = AsyncMock()
            ws_connections[123] = [admin_ws]
            ws_site_connections[123] = [widget_ws]
    
            with patch('api.site.models.DialogMessage', return_value=mock_message):
                # Simulate widget API call
&gt;               client = TestClient(app)
                         ^^^^^^^^^^^^^^^

tests/test_integration_realtime.py:120: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;starlette.testclient.TestClient object at 0x10adddbd0&gt;
app = &lt;fastapi.applications.FastAPI object at 0x10756a3c0&gt;
base_url = 'http://testserver', raise_server_exceptions = True, root_path = ''
backend = 'asyncio', backend_options = None, cookies = None
headers = {'user-agent': 'testclient'}, follow_redirects = True

    def __init__(
        self,
        app: ASGIApp,
        base_url: str = "http://testserver",
        raise_server_exceptions: bool = True,
        root_path: str = "",
        backend: typing.Literal["asyncio", "trio"] = "asyncio",
        backend_options: dict[str, typing.Any] | None = None,
        cookies: httpx._types.CookieTypes | None = None,
        headers: dict[str, str] | None = None,
        follow_redirects: bool = True,
    ) -&gt; None:
        self.async_backend = _AsyncBackend(
            backend=backend, backend_options=backend_options or {}
        )
        if _is_asgi3(app):
            asgi_app = app
        else:
            app = typing.cast(ASGI2App, app)  # type: ignore[assignment]
            asgi_app = _WrapASGI2(app)  # type: ignore[arg-type]
        self.app = asgi_app
        self.app_state: dict[str, typing.Any] = {}
        transport = _TestClientTransport(
            self.app,
            portal_factory=self._portal_factory,
            raise_server_exceptions=raise_server_exceptions,
            root_path=root_path,
            app_state=self.app_state,
        )
        if headers is None:
            headers = {}
        headers.setdefault("user-agent", "testclient")
&gt;       super().__init__(
            app=self.app,
            base_url=base_url,
            headers=headers,
            transport=transport,
            follow_redirects=follow_redirects,
            cookies=cookies,
        )
E       TypeError: Client.__init__() got an unexpected keyword argument 'app'

/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/starlette/testclient.py:429: TypeError</failure></testcase><testcase classname="tests.test_integration_realtime.TestRealTimeIntegration" name="test_ai_response_cross_channel_delivery" time="0.001"><failure message="TypeError: Client.__init__() got an unexpected keyword argument 'app'">self = &lt;test_integration_realtime.TestRealTimeIntegration object at 0x10a87a8b0&gt;

    @pytest.mark.asyncio
    async def test_ai_response_cross_channel_delivery(self):
        """Test AI response delivery to both admin and widget channels"""
    
        with patch('database.get_db') as mock_get_db:
            mock_db = Mock()
            mock_get_db.return_value = mock_db
    
            # Mock assistant and dialog
            mock_assistant = Mock()
            mock_assistant.user_id = 1
            mock_dialog = Mock()
            mock_dialog.id = 123
            mock_dialog.handoff_status = 'none'
    
            mock_user_message = Mock()
            mock_user_message.id = 100
            mock_user_message.sender = 'user'
            mock_user_message.text = 'User question'
            mock_user_message.timestamp.isoformat.return_value = '2025-01-15T10:30:00'
    
            mock_ai_message = Mock()
            mock_ai_message.id = 101
            mock_ai_message.sender = 'assistant'
            mock_ai_message.text = 'AI response'
            mock_ai_message.timestamp.isoformat.return_value = '2025-01-15T10:31:00'
    
            mock_db.query.return_value.filter.return_value.first.side_effect = [
                mock_assistant,
                mock_dialog
            ]
            mock_db.add = Mock()
            mock_db.commit = Mock()
            mock_db.refresh = Mock()
    
            # Mock WebSocket connections
            admin_ws = AsyncMock()
            widget_ws = AsyncMock()
            ws_connections[123] = [admin_ws]
            ws_site_connections[123] = [widget_ws]
    
            with patch('api.site.models.DialogMessage', return_value=mock_user_message):
                with patch('api.site.generate_ai_response', return_value=mock_ai_message):
                    # Simulate widget API call that triggers AI response
&gt;                   client = TestClient(app)
                             ^^^^^^^^^^^^^^^

tests/test_integration_realtime.py:184: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;starlette.testclient.TestClient object at 0x10adde350&gt;
app = &lt;fastapi.applications.FastAPI object at 0x10756a3c0&gt;
base_url = 'http://testserver', raise_server_exceptions = True, root_path = ''
backend = 'asyncio', backend_options = None, cookies = None
headers = {'user-agent': 'testclient'}, follow_redirects = True

    def __init__(
        self,
        app: ASGIApp,
        base_url: str = "http://testserver",
        raise_server_exceptions: bool = True,
        root_path: str = "",
        backend: typing.Literal["asyncio", "trio"] = "asyncio",
        backend_options: dict[str, typing.Any] | None = None,
        cookies: httpx._types.CookieTypes | None = None,
        headers: dict[str, str] | None = None,
        follow_redirects: bool = True,
    ) -&gt; None:
        self.async_backend = _AsyncBackend(
            backend=backend, backend_options=backend_options or {}
        )
        if _is_asgi3(app):
            asgi_app = app
        else:
            app = typing.cast(ASGI2App, app)  # type: ignore[assignment]
            asgi_app = _WrapASGI2(app)  # type: ignore[arg-type]
        self.app = asgi_app
        self.app_state: dict[str, typing.Any] = {}
        transport = _TestClientTransport(
            self.app,
            portal_factory=self._portal_factory,
            raise_server_exceptions=raise_server_exceptions,
            root_path=root_path,
            app_state=self.app_state,
        )
        if headers is None:
            headers = {}
        headers.setdefault("user-agent", "testclient")
&gt;       super().__init__(
            app=self.app,
            base_url=base_url,
            headers=headers,
            transport=transport,
            follow_redirects=follow_redirects,
            cookies=cookies,
        )
E       TypeError: Client.__init__() got an unexpected keyword argument 'app'

/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/starlette/testclient.py:429: TypeError</failure></testcase><testcase classname="tests.test_integration_realtime.TestWebSocketEndpointIntegration" name="test_websocket_endpoint_authentication_flow" time="0.001"><failure message="TypeError: Client.__init__() got an unexpected keyword argument 'app'">self = &lt;test_integration_realtime.TestWebSocketEndpointIntegration object at 0x10ac70690&gt;

    @pytest.mark.asyncio
    async def test_websocket_endpoint_authentication_flow(self):
        """Test complete WebSocket authentication flow"""
    
        # Test admin WebSocket endpoint
        with patch('core.auth.get_user_from_token') as mock_auth:
            mock_user = Mock()
            mock_user.id = 1
            mock_auth.return_value = mock_user
    
            with patch('database.get_db') as mock_get_db:
                mock_db = Mock()
                mock_get_db.return_value = mock_db
    
                # Test WebSocket connection
&gt;               client = TestClient(app)
                         ^^^^^^^^^^^^^^^

tests/test_integration_realtime.py:227: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;starlette.testclient.TestClient object at 0x10aff88a0&gt;
app = &lt;fastapi.applications.FastAPI object at 0x10756a3c0&gt;
base_url = 'http://testserver', raise_server_exceptions = True, root_path = ''
backend = 'asyncio', backend_options = None, cookies = None
headers = {'user-agent': 'testclient'}, follow_redirects = True

    def __init__(
        self,
        app: ASGIApp,
        base_url: str = "http://testserver",
        raise_server_exceptions: bool = True,
        root_path: str = "",
        backend: typing.Literal["asyncio", "trio"] = "asyncio",
        backend_options: dict[str, typing.Any] | None = None,
        cookies: httpx._types.CookieTypes | None = None,
        headers: dict[str, str] | None = None,
        follow_redirects: bool = True,
    ) -&gt; None:
        self.async_backend = _AsyncBackend(
            backend=backend, backend_options=backend_options or {}
        )
        if _is_asgi3(app):
            asgi_app = app
        else:
            app = typing.cast(ASGI2App, app)  # type: ignore[assignment]
            asgi_app = _WrapASGI2(app)  # type: ignore[arg-type]
        self.app = asgi_app
        self.app_state: dict[str, typing.Any] = {}
        transport = _TestClientTransport(
            self.app,
            portal_factory=self._portal_factory,
            raise_server_exceptions=raise_server_exceptions,
            root_path=root_path,
            app_state=self.app_state,
        )
        if headers is None:
            headers = {}
        headers.setdefault("user-agent", "testclient")
&gt;       super().__init__(
            app=self.app,
            base_url=base_url,
            headers=headers,
            transport=transport,
            follow_redirects=follow_redirects,
            cookies=cookies,
        )
E       TypeError: Client.__init__() got an unexpected keyword argument 'app'

/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/starlette/testclient.py:429: TypeError</failure></testcase><testcase classname="tests.test_integration_realtime.TestWebSocketEndpointIntegration" name="test_multiple_websocket_connections" time="0.002" /><testcase classname="tests.test_integration_realtime.TestHandoffIntegration" name="test_handoff_request_event_propagation" time="0.001" /><testcase classname="tests.test_integration_realtime.TestHandoffIntegration" name="test_handoff_started_event_propagation" time="0.001" /><testcase classname="tests.test_integration_realtime.TestMessageFormatsIntegration" name="test_direct_message_format_delivery" time="0.001" /><testcase classname="tests.test_integration_realtime.TestMessageFormatsIntegration" name="test_wrapped_message_format_delivery" time="0.001" /><testcase classname="tests.test_integration_realtime.TestErrorRecoveryIntegration" name="test_websocket_connection_failure_recovery" time="0.001"><failure message="AttributeError: 'list' object has no attribute 'discard'">dialog_id = 123
message = {'id': 456, 'sender': 'manager', 'text': 'Test message', 'timestamp': '2025-01-15T10:30:00Z'}

    async def push_dialog_message(dialog_id: int, message: dict):
        """Отправляет сообщение всем подключенным клиентам диалога (админ панель)"""
        async with await _get_dialog_lock(dialog_id):
            conns = ws_connections.get(dialog_id, set())
            logger.info(f"Push to ADMIN dialog {dialog_id}: {len(conns)} connections")
            logger.debug(f"Admin message: {message}")
    
            if not conns:
                logger.warning(f"No ADMIN WebSocket connections found for dialog {dialog_id}")
                logger.debug(f"Available ADMIN dialogs: {list(ws_connections.keys())}")
                return
    
            sent_count = 0
            # Создаем копию set для итерации, чтобы избежать изменений во время итерации
            for ws in conns.copy():
                try:
&gt;                   await ws.send_json(message)

services/websocket_manager.py:503: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;AsyncMock name='mock.send_json' id='4477235760'&gt;
args = ({'id': 456, 'sender': 'manager', 'text': 'Test message', 'timestamp': '2025-01-15T10:30:00Z'},)
kwargs = {}
_call = call({'id': 456, 'sender': 'manager', 'text': 'Test message', 'timestamp': '2025-01-15T10:30:00Z'})
effect = Exception('Connection failed')

    async def _execute_mock_call(self, /, *args, **kwargs):
        # This is nearly just like super(), except for special handling
        # of coroutines
    
        _call = _Call((args, kwargs), two=True)
        self.await_count += 1
        self.await_args = _call
        self.await_args_list.append(_call)
    
        effect = self.side_effect
        if effect is not None:
            if _is_exception(effect):
&gt;               raise effect
E               Exception: Connection failed

/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py:2321: Exception

During handling of the above exception, another exception occurred:

self = &lt;test_integration_realtime.TestErrorRecoveryIntegration object at 0x10ac70e10&gt;

    @pytest.mark.asyncio
    async def test_websocket_connection_failure_recovery(self):
        """Test recovery from WebSocket connection failures"""
    
        from services.websocket_manager import push_dialog_message
    
        dialog_id = 123
    
        # Create failing and working WebSocket mocks
        failing_ws = AsyncMock()
        failing_ws.send_json.side_effect = Exception("Connection failed")
    
        working_ws = AsyncMock()
    
        ws_connections[dialog_id] = [failing_ws, working_ws]
    
        message = {
            "id": 456,
            "sender": "manager",
            "text": "Test message",
            "timestamp": "2025-01-15T10:30:00Z"
        }
    
        # Should not raise exception despite one failing connection
&gt;       await push_dialog_message(dialog_id, message)

tests/test_integration_realtime.py:432: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
services/websocket_manager.py:509: in push_dialog_message
    await _drop_socket(ws_connections, ws_meta, dialog_id, ws, reason="Send failed")
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

bucket = {123: [&lt;AsyncMock id='4477236432'&gt;, &lt;AsyncMock id='4477233072'&gt;]}
meta_bucket = {}, dialog_id = 123, ws = &lt;AsyncMock id='4477236432'&gt;, code = 1001
reason = 'Send failed'

    async def _drop_socket(bucket: Dict[int, Set[WebSocket]], meta_bucket: Dict[int, Dict[WebSocket, Dict[str, float]]], dialog_id: int, ws: WebSocket, code=WSCloseCodes.GOING_AWAY, reason="Connection dropped"):
        """Безопасно удаляет сокет из всех структур данных"""
        global _total_connections
    
        conns = bucket.get(dialog_id, set())
        if ws in conns:
&gt;           conns.discard(ws)
            ^^^^^^^^^^^^^
E           AttributeError: 'list' object has no attribute 'discard'

services/websocket_manager.py:236: AttributeError</failure></testcase><testcase classname="tests.test_integration_realtime.TestErrorRecoveryIntegration" name="test_message_delivery_with_no_connections" time="0.001" /><testcase classname="tests.test_integration_realtime.TestPerformanceIntegration" name="test_high_volume_message_delivery" time="0.014" /><testcase classname="tests.test_integration_realtime.TestPerformanceIntegration" name="test_concurrent_dialog_messaging" time="0.013" /><testcase classname="tests.test_realtime_api.TestDialogAPIRealtime" name="test_add_dialog_message_websocket_routing" time="0.002"><failure message="fastapi.exceptions.HTTPException: 403: You can only reply as manager in your own dialogs">self = &lt;test_realtime_api.TestDialogAPIRealtime object at 0x10ac71590&gt;
mock_push_site = &lt;AsyncMock name='push_site_dialog_message' id='4486181760'&gt;
mock_push_admin = &lt;AsyncMock name='push_dialog_message' id='4486182432'&gt;

    @pytest.mark.asyncio
    @patch('api.dialogs.push_dialog_message')
    @patch('api.dialogs.push_site_dialog_message')
    async def test_add_dialog_message_websocket_routing(self, mock_push_site, mock_push_admin):
        """Test that messages are routed correctly through WebSocket"""
        from api.dialogs import add_dialog_message
    
        # Mock database objects
        mock_db = Mock()
        mock_user = Mock()
        mock_dialog = Mock(id=123, handoff_status='none')
        mock_message = Mock(
            id=456,
            sender='manager',
            text='Test message',
            timestamp='2025-01-15T10:30:00Z'
        )
    
        mock_db.query.return_value.filter.return_value.first.return_value = mock_dialog
        mock_db.add = Mock()
        mock_db.commit = Mock()
        mock_db.refresh = Mock()
    
        with patch('api.dialogs.models.DialogMessage', return_value=mock_message):
            data = {"sender": "manager", "text": "Test message"}
    
            # Execute
&gt;           result = await add_dialog_message(
                dialog_id=123,
                data=data,
                current_user=mock_user,
                db=mock_db
            )

tests/test_realtime_api.py:50: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dialog_id = 123, data = {'sender': 'manager', 'text': 'Test message'}
db = &lt;Mock id='4486183104'&gt;, current_user = &lt;Mock id='4486183440'&gt;

    @router.post("/dialogs/{dialog_id}/messages")
    async def add_dialog_message(dialog_id: int, data: dict, db: Session = Depends(get_db), current_user: models.User = Depends(auth.get_current_user)):
        from validators.input_validator import validate_message_data, ValidationError, create_validation_error_response
        from services.balance_service import BalanceService
    
        # Валидация входных данных
        try:
            validated_data = validate_message_data(data)
        except ValidationError as e:
            raise create_validation_error_response(e)
    
        dialog = db.query(models.Dialog).filter(models.Dialog.id == dialog_id).first()
        if not dialog:
            raise HTTPException(status_code=404, detail="Dialog not found")
    
        # HANDOFF INTEGRATION: Проверка прав для менеджера
        sender = validated_data.get('sender', 'user')
        if sender == 'manager':
            logger.info(f"#x1F510 [DIALOGS] Проверка прав менеджера. User ID: {current_user.id}")
            logger.info(f"#x1F510 [DIALOGS] Диалог #{dialog_id}: user_id={dialog.user_id}")
    
            # В системе нет ролей - каждый пользователь может отвечать как менеджер в СВОИХ диалогах
            # Или админ может отвечать в любых диалогах
            is_admin = getattr(current_user, 'role', None) == 'admin'
            is_dialog_owner = dialog.user_id == current_user.id
    
            logger.info(f"#x1F510 [DIALOGS] is_admin: {is_admin}, is_dialog_owner: {is_dialog_owner}")
    
            if not (is_admin or is_dialog_owner):
                logger.error(f"❌ [DIALOGS] Отказано в доступе. Пользователь {current_user.id} может отвечать как менеджер только в своих диалогах (dialog.user_id={dialog.user_id})")
&gt;               raise HTTPException(status_code=403, detail="You can only reply as manager in your own dialogs")
E               fastapi.exceptions.HTTPException: 403: You can only reply as manager in your own dialogs

api/dialogs.py:437: HTTPException</failure></testcase><testcase classname="tests.test_realtime_api.TestDialogAPIRealtime" name="test_widget_user_message_admin_only" time="0.003"><failure message="fastapi.exceptions.HTTPException: 402: {'error': 'payment_failed', 'message': 'Ошибка списания средств. Попробуйте позже.', 'needsTopUp': True}">dialog_id = 123, data = {'sender': 'user', 'text': 'User message from widget'}
assistant_id = 456, guest_id = 'guest123', db = &lt;Mock id='4486420464'&gt;

    @router.post('/widget/dialogs/{dialog_id}/messages')
    async def widget_add_dialog_message(
        dialog_id: int,
        data: dict,
        assistant_id: int,
        guest_id: str = Query(...),
        db: Session = Depends(get_db)
    ):
        """Добавляет сообщение в widget диалог"""
        # Получаем ассистента и его пользователя
        assistant = db.query(models.Assistant).filter(models.Assistant.id == assistant_id).first()
        if not assistant:
            raise HTTPException(status_code=404, detail="Assistant not found")
    
        dialog = db.query(models.Dialog).filter(
            models.Dialog.id == dialog_id,
            models.Dialog.user_id == assistant.user_id,
            models.Dialog.guest_id == guest_id
        ).first()
    
        if not dialog:
            raise HTTPException(status_code=404, detail="Dialog not found")
    
        # CHECK IF WIDGET DIALOG IS TAKEN OVER - блокируем AI при запросе И взятии оператором (как в телеграме)
        is_taken_over = getattr(dialog, 'handoff_status', 'none') in ['requested', 'active']
    
        # If dialog is taken over, only allow manager messages, no AI responses
        if is_taken_over and data.get('sender') == 'user':
            logger.info(f"Widget dialog {dialog_id} is taken over, blocking AI response")
    
        sender = data.get('sender')
        text = data.get('text')
        if not text:
            raise HTTPException(status_code=400, detail="Text required")
    
        # Создаем сообщение
        msg = models.DialogMessage(dialog_id=dialog_id, sender=sender, text=text)
        db.add(msg)
        db.commit()
        db.refresh(msg)
    
        # Для сообщений пользователя отправляем только в админ панель
        # НЕ отправляем в виджет, так как виджет уже добавляет оптимистично
        if msg.sender == 'user':
            user_message_data = {
                "id": msg.id,
                "sender": msg.sender,
                "text": msg.text,
                "timestamp": msg.timestamp.isoformat() + 'Z'
            }
            await push_dialog_message(dialog_id, user_message_data)
        else:
            # Для сообщений НЕ от пользователя (менеджер, система) отправляем в оба канала
            message_data = {
                "id": msg.id,
                "sender": msg.sender,
                "text": msg.text,
                "timestamp": msg.timestamp.isoformat() + 'Z'
            }
            await push_dialog_message(dialog_id, message_data)
            await ws_push_site_dialog_message(dialog_id, message_data)
    
        response_msg = None
        if sender == 'user' and not is_taken_over:
            # АВТОТРИГГЕР для widget: Проверяем триггерные фразы ПЕРЕД генерацией ответа
            handoff_service = HandoffService(db)
            trigger_keywords = ['оператор', 'человек', 'менеджер', 'поддержка', 'помощь', 'жалоба', 'проблема']
            user_text = text.lower() if text else ''
    
            # Проверяем не был ли недавно освобожден диалог (избегаем ложных срабатываний)
            recent_release = db.query(models.HandoffAudit).filter(
                models.HandoffAudit.dialog_id == dialog_id,
                models.HandoffAudit.to_status == 'released',
                models.HandoffAudit.created_at &gt; datetime.now() - timedelta(minutes=5)
            ).first()
    
            should_trigger_handoff = (
                any(keyword in user_text for keyword in trigger_keywords) and
                not recent_release and
                dialog.handoff_status != 'requested' and
                dialog.handoff_status != 'active'
            )
    
            if should_trigger_handoff:
                try:
                    from uuid import uuid4
                    new_request_id = str(uuid4())
                    logger.info(f"Auto-triggering handoff for widget dialog {dialog_id} due to keywords: {user_text[:100]}")
                    handoff_result = handoff_service.request_handoff(
                        dialog_id=dialog_id,
                        reason="auto_trigger",
                        request_id=new_request_id,
                        last_user_text=text[:200] if text else None
                    )
    
                    # Отправляем уведомление о запросе оператора
                    await ws_push_site_dialog_message(dialog_id, {
                        "type": "handoff_requested",
                        "message": "Ваш запрос передан оператору. Пожалуйста, подождите..."
                    })
    
                    # Останавливаем генерацию AI ответа
                    await ws_push_site_dialog_message(dialog_id, {"type": "typing_stop"})
    
                    return {
                        "user_message": {
                            "id": msg.id,
                            "sender": msg.sender,
                            "text": msg.text,
                            "timestamp": msg.timestamp.strftime('%Y-%m-%d %H:%M:%S')
                        },
                        "handoff_triggered": True,
                        "handoff_status": handoff_result.status
                    }
    
                except Exception as e:
                    logger.error(f"Failed to auto-trigger handoff: {e}")
                    # НЕ продолжаем с AI ответом даже при ошибке handoff
                    return {
                        "user_message": {
                            "id": msg.id,
                            "sender": msg.sender,
                            "text": msg.text,
                            "timestamp": msg.timestamp.strftime('%Y-%m-%d %H:%M:%S')
                        },
                        "handoff_triggered": True,
                        "handoff_error": str(e)
                    }
    
            # Отправляем typing_start только если handoff НЕ сработал
            await ws_push_site_dialog_message(dialog_id, {"type": "typing_start"})
    
            # Списываем средства за AI сообщение ПЕРЕД генерацией ответа (widget)
            user = db.query(models.User).filter(models.User.id == assistant.user_id).first()
            if not user:
                logger.error(f"User not found for assistant {assistant_id}")
                await ws_push_site_dialog_message(dialog_id, {"type": "typing_stop"})
                raise HTTPException(status_code=404, detail="User not found")
    
            balance_service = BalanceService(db)
            try:
&gt;               transaction = balance_service.charge_for_service(
                    user.id,
                    'widget_message',
                    f"AI сообщение в виджете (диалог #{dialog_id})",
                    msg.id  # related_id - ID пользовательского сообщения
                )

api/site.py:677: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;services.balance_service.BalanceService object at 0x10b697b60&gt;
user_id = &lt;Mock name='mock.query().filter().first().id' id='4486429872'&gt;
service_type = 'widget_message'
description = 'AI сообщение в виджете (диалог #123)', related_id = 789

    def charge_for_service(self, user_id: int, service_type: str, description: Optional[str] = None, related_id: Optional[int] = None) -&gt; BalanceTransaction:
        """Списать средства за услугу"""
        # Получаем цену услуги
        service_price = self.db.query(ServicePrice).filter(
            ServicePrice.service_type == service_type,
            ServicePrice.is_active == True
        ).first()
    
        if not service_price:
            logger.error(f"Цена для услуги {service_type} не найдена")
            raise ValueError(f"Цена для услуги {service_type} не найдена")
    
        amount = service_price.price
        balance = self.get_or_create_balance(user_id)
    
        # Проверяем достаточность средств
&gt;       if balance.balance &lt; amount:
           ^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: '&lt;' not supported between instances of 'Mock' and 'Mock'

services/balance_service.py:83: TypeError

During handling of the above exception, another exception occurred:

self = &lt;test_realtime_api.TestDialogAPIRealtime object at 0x10ac71310&gt;
mock_push_site = &lt;AsyncMock name='ws_push_site_dialog_message' id='4486419120'&gt;
mock_push_admin = &lt;AsyncMock name='push_dialog_message' id='4486419792'&gt;

    @pytest.mark.asyncio
    @patch('api.site.push_dialog_message')
    @patch('api.site.ws_push_site_dialog_message')
    async def test_widget_user_message_admin_only(self, mock_push_site, mock_push_admin):
        """Test that user messages from widget only go to admin panel"""
        from api.site import widget_add_dialog_message
    
        # Mock database objects
        mock_db = Mock()
        mock_assistant = Mock(user_id=1)
        mock_dialog = Mock(id=123, handoff_status='none')
        mock_message = Mock(
            id=789,
            sender='user',
            text='User message from widget'
        )
        mock_message.timestamp.isoformat.return_value = '2025-01-15T10:30:00'
    
        mock_db.query.return_value.filter.return_value.first.return_value = mock_assistant
        mock_db.query.return_value.filter.return_value.filter.return_value.first.return_value = mock_dialog
        mock_db.add = Mock()
        mock_db.commit = Mock()
        mock_db.refresh = Mock()
    
        with patch('api.site.models.DialogMessage', return_value=mock_message):
            data = {"sender": "user", "text": "User message from widget"}
    
            # Execute
&gt;           result = await widget_add_dialog_message(
                dialog_id=123,
                data=data,
                assistant_id=456,
                guest_id="guest123",
                db=mock_db
            )

tests/test_realtime_api.py:96: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dialog_id = 123, data = {'sender': 'user', 'text': 'User message from widget'}
assistant_id = 456, guest_id = 'guest123', db = &lt;Mock id='4486420464'&gt;

    @router.post('/widget/dialogs/{dialog_id}/messages')
    async def widget_add_dialog_message(
        dialog_id: int,
        data: dict,
        assistant_id: int,
        guest_id: str = Query(...),
        db: Session = Depends(get_db)
    ):
        """Добавляет сообщение в widget диалог"""
        # Получаем ассистента и его пользователя
        assistant = db.query(models.Assistant).filter(models.Assistant.id == assistant_id).first()
        if not assistant:
            raise HTTPException(status_code=404, detail="Assistant not found")
    
        dialog = db.query(models.Dialog).filter(
            models.Dialog.id == dialog_id,
            models.Dialog.user_id == assistant.user_id,
            models.Dialog.guest_id == guest_id
        ).first()
    
        if not dialog:
            raise HTTPException(status_code=404, detail="Dialog not found")
    
        # CHECK IF WIDGET DIALOG IS TAKEN OVER - блокируем AI при запросе И взятии оператором (как в телеграме)
        is_taken_over = getattr(dialog, 'handoff_status', 'none') in ['requested', 'active']
    
        # If dialog is taken over, only allow manager messages, no AI responses
        if is_taken_over and data.get('sender') == 'user':
            logger.info(f"Widget dialog {dialog_id} is taken over, blocking AI response")
    
        sender = data.get('sender')
        text = data.get('text')
        if not text:
            raise HTTPException(status_code=400, detail="Text required")
    
        # Создаем сообщение
        msg = models.DialogMessage(dialog_id=dialog_id, sender=sender, text=text)
        db.add(msg)
        db.commit()
        db.refresh(msg)
    
        # Для сообщений пользователя отправляем только в админ панель
        # НЕ отправляем в виджет, так как виджет уже добавляет оптимистично
        if msg.sender == 'user':
            user_message_data = {
                "id": msg.id,
                "sender": msg.sender,
                "text": msg.text,
                "timestamp": msg.timestamp.isoformat() + 'Z'
            }
            await push_dialog_message(dialog_id, user_message_data)
        else:
            # Для сообщений НЕ от пользователя (менеджер, система) отправляем в оба канала
            message_data = {
                "id": msg.id,
                "sender": msg.sender,
                "text": msg.text,
                "timestamp": msg.timestamp.isoformat() + 'Z'
            }
            await push_dialog_message(dialog_id, message_data)
            await ws_push_site_dialog_message(dialog_id, message_data)
    
        response_msg = None
        if sender == 'user' and not is_taken_over:
            # АВТОТРИГГЕР для widget: Проверяем триггерные фразы ПЕРЕД генерацией ответа
            handoff_service = HandoffService(db)
            trigger_keywords = ['оператор', 'человек', 'менеджер', 'поддержка', 'помощь', 'жалоба', 'проблема']
            user_text = text.lower() if text else ''
    
            # Проверяем не был ли недавно освобожден диалог (избегаем ложных срабатываний)
            recent_release = db.query(models.HandoffAudit).filter(
                models.HandoffAudit.dialog_id == dialog_id,
                models.HandoffAudit.to_status == 'released',
                models.HandoffAudit.created_at &gt; datetime.now() - timedelta(minutes=5)
            ).first()
    
            should_trigger_handoff = (
                any(keyword in user_text for keyword in trigger_keywords) and
                not recent_release and
                dialog.handoff_status != 'requested' and
                dialog.handoff_status != 'active'
            )
    
            if should_trigger_handoff:
                try:
                    from uuid import uuid4
                    new_request_id = str(uuid4())
                    logger.info(f"Auto-triggering handoff for widget dialog {dialog_id} due to keywords: {user_text[:100]}")
                    handoff_result = handoff_service.request_handoff(
                        dialog_id=dialog_id,
                        reason="auto_trigger",
                        request_id=new_request_id,
                        last_user_text=text[:200] if text else None
                    )
    
                    # Отправляем уведомление о запросе оператора
                    await ws_push_site_dialog_message(dialog_id, {
                        "type": "handoff_requested",
                        "message": "Ваш запрос передан оператору. Пожалуйста, подождите..."
                    })
    
                    # Останавливаем генерацию AI ответа
                    await ws_push_site_dialog_message(dialog_id, {"type": "typing_stop"})
    
                    return {
                        "user_message": {
                            "id": msg.id,
                            "sender": msg.sender,
                            "text": msg.text,
                            "timestamp": msg.timestamp.strftime('%Y-%m-%d %H:%M:%S')
                        },
                        "handoff_triggered": True,
                        "handoff_status": handoff_result.status
                    }
    
                except Exception as e:
                    logger.error(f"Failed to auto-trigger handoff: {e}")
                    # НЕ продолжаем с AI ответом даже при ошибке handoff
                    return {
                        "user_message": {
                            "id": msg.id,
                            "sender": msg.sender,
                            "text": msg.text,
                            "timestamp": msg.timestamp.strftime('%Y-%m-%d %H:%M:%S')
                        },
                        "handoff_triggered": True,
                        "handoff_error": str(e)
                    }
    
            # Отправляем typing_start только если handoff НЕ сработал
            await ws_push_site_dialog_message(dialog_id, {"type": "typing_start"})
    
            # Списываем средства за AI сообщение ПЕРЕД генерацией ответа (widget)
            user = db.query(models.User).filter(models.User.id == assistant.user_id).first()
            if not user:
                logger.error(f"User not found for assistant {assistant_id}")
                await ws_push_site_dialog_message(dialog_id, {"type": "typing_stop"})
                raise HTTPException(status_code=404, detail="User not found")
    
            balance_service = BalanceService(db)
            try:
                transaction = balance_service.charge_for_service(
                    user.id,
                    'widget_message',
                    f"AI сообщение в виджете (диалог #{dialog_id})",
                    msg.id  # related_id - ID пользовательского сообщения
                )
                logger.info(f"Списано {abs(transaction.amount)} руб. за AI сообщение в виджете пользователя {user.id}")
            except ValueError as e:
                logger.error(f"Ошибка списания средств за AI сообщение в виджете: {e}")
                await ws_push_site_dialog_message(dialog_id, {"type": "typing_stop"})
                raise HTTPException(
                    status_code=402,
                    detail={
                        "error": "insufficient_funds",
                        "message": "Недостаточно средств для отправки AI сообщения",
                        "needsTopUp": True
                    }
                )
            except Exception as e:
                logger.error(f"Ошибка списания средств за AI сообщение в виджете: {e}")
                await ws_push_site_dialog_message(dialog_id, {"type": "typing_stop"})
&gt;               raise HTTPException(
                    status_code=402,
                    detail={
                        "error": "payment_failed",
                        "message": "Ошибка списания средств. Попробуйте позже.",
                        "needsTopUp": True
                    }
                )
E               fastapi.exceptions.HTTPException: 402: {'error': 'payment_failed', 'message': 'Ошибка списания средств. Попробуйте позже.', 'needsTopUp': True}

api/site.py:698: HTTPException</failure></testcase><testcase classname="tests.test_realtime_api.TestSiteAPIRealtime" name="test_site_ai_response_both_channels" time="0.002"><failure message="TypeError: '&gt;=' not supported between instances of 'MagicMock' and 'datetime.datetime'">self = &lt;test_realtime_api.TestSiteAPIRealtime object at 0x10ac716d0&gt;
mock_push_site = &lt;AsyncMock name='ws_push_site_dialog_message' id='4486710672'&gt;
mock_push_admin = &lt;AsyncMock name='push_dialog_message' id='4486711344'&gt;

    @pytest.mark.asyncio
    @patch('api.site.push_dialog_message')
    @patch('api.site.ws_push_site_dialog_message')
    async def test_site_ai_response_both_channels(self, mock_push_site, mock_push_admin):
        """Test that AI responses go to both admin and widget channels"""
        from api.site import site_add_dialog_message
    
        # Mock database and AI response
        mock_db = Mock()
        mock_user = Mock(id=1)
        mock_dialog = Mock(id=123, handoff_status='none')
        mock_user_message = Mock(
            id=101,
            sender='user',
            text='User question'
        )
        mock_ai_message = Mock(
            id=102,
            sender='assistant',
            text='AI response'
        )
    
        # Setup timestamp mocks
        mock_user_message.timestamp.isoformat.return_value = '2025-01-15T10:30:00'
        mock_ai_message.timestamp.isoformat.return_value = '2025-01-15T10:31:00'
    
        mock_db.query.return_value.filter.return_value.first.return_value = mock_dialog
        mock_db.add = Mock()
        mock_db.commit = Mock()
        mock_db.refresh = Mock()
    
        with patch('api.site.models.DialogMessage', return_value=mock_user_message):
            with patch('api.site.generate_ai_response', return_value=mock_ai_message):
                data = {"sender": "user", "text": "User question"}
    
                # Execute
&gt;               result = await site_add_dialog_message(
                    dialog_id=123,
                    data=data,
                    guest_id="guest123",
                    db=mock_db,
                    current_user=mock_user
                )

tests/test_realtime_api.py:155: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dialog_id = 123, data = {'sender': 'user', 'text': 'User question'}
guest_id = 'guest123', db = &lt;Mock id='4486712016'&gt;
current_user = &lt;Mock id='4486712352'&gt;

    @router.post('/site/dialogs/{dialog_id}/messages')
    async def site_add_dialog_message(
        dialog_id: int,
        data: dict,
        guest_id: str = Query(...),
        db: Session = Depends(get_db),
        current_user: models.User = Depends(get_current_site_user)
    ):
        """Добавляет сообщение в site диалог"""
        dialog = db.query(models.Dialog).filter(
            models.Dialog.id == dialog_id,
            models.Dialog.user_id == current_user.id,
            models.Dialog.guest_id == guest_id
        ).first()
    
        if not dialog:
            raise HTTPException(status_code=404, detail="Dialog not found")
    
        # CHECK IF DIALOG IS TAKEN OVER - блокируем AI при запросе И взятии оператором (как в телеграме)
        is_taken_over = getattr(dialog, 'handoff_status', 'none') in ['requested', 'active']
    
        # If dialog is taken over, only allow manager messages, no AI responses
        if is_taken_over and data.get('sender') == 'user':
            logger.info(f"Dialog {dialog_id} is taken over, blocking AI response")
            # Don't generate AI response for taken over dialogs
            pass
    
        sender = data.get('sender')
        text = data.get('text')
        if not text:
            raise HTTPException(status_code=400, detail="Text required")
    
        # Проверка блокировки пользователя
        if is_user_blocked(current_user):
            raise HTTPException(
                status_code=403,
                detail={
                    "error": "trial_expired",
                    "message": "Ваш пробный период завершился. Обновите план для продолжения использования.",
                    "needsUpgrade": True
                }
            )
    
        # Лимит по тарифу
        limit = get_user_message_limit(current_user)
        month_ago = datetime.utcnow().replace(day=1, hour=0, minute=0, second=0, microsecond=0)
        msg_count = db.query(models.DialogMessage).join(models.Dialog).filter(
            models.Dialog.user_id == current_user.id,
            models.Dialog.guest_id == guest_id,
&gt;           models.DialogMessage.timestamp &gt;= month_ago,
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            models.DialogMessage.sender == 'assistant'
        ).count()
E       TypeError: '&gt;=' not supported between instances of 'MagicMock' and 'datetime.datetime'

api/site.py:199: TypeError</failure></testcase><testcase classname="tests.test_realtime_api.TestHandoffEventRouting" name="test_handoff_events_all_channels" time="0.001" /><testcase classname="tests.test_realtime_api.TestWebSocketEndpointIntegration" name="test_admin_websocket_authentication" time="0.001" /><testcase classname="tests.test_realtime_api.TestWebSocketEndpointIntegration" name="test_widget_websocket_assistant_validation" time="0.002" /><testcase classname="tests.test_realtime_api.TestMessageDeduplication" name="test_message_id_uniqueness" time="0.031" /><testcase classname="tests.test_realtime_api.TestOptimisticUpdates" name="test_optimistic_message_replacement" time="0.001" /><testcase classname="tests.test_realtime_api.TestErrorHandling" name="test_websocket_connection_failure_handling" time="0.002"><failure message="AttributeError: 'list' object has no attribute 'discard'">dialog_id = 123, message = {'id': 1, 'text': 'test'}

    async def push_dialog_message(dialog_id: int, message: dict):
        """Отправляет сообщение всем подключенным клиентам диалога (админ панель)"""
        async with await _get_dialog_lock(dialog_id):
            conns = ws_connections.get(dialog_id, set())
            logger.info(f"Push to ADMIN dialog {dialog_id}: {len(conns)} connections")
            logger.debug(f"Admin message: {message}")
    
            if not conns:
                logger.warning(f"No ADMIN WebSocket connections found for dialog {dialog_id}")
                logger.debug(f"Available ADMIN dialogs: {list(ws_connections.keys())}")
                return
    
            sent_count = 0
            # Создаем копию set для итерации, чтобы избежать изменений во время итерации
            for ws in conns.copy():
                try:
&gt;                   await ws.send_json(message)

services/websocket_manager.py:503: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;AsyncMock name='mock.send_json' id='4486723104'&gt;
args = ({'id': 1, 'text': 'test'},), kwargs = {}
_call = call({'id': 1, 'text': 'test'}), effect = Exception('Connection lost')

    async def _execute_mock_call(self, /, *args, **kwargs):
        # This is nearly just like super(), except for special handling
        # of coroutines
    
        _call = _Call((args, kwargs), two=True)
        self.await_count += 1
        self.await_args = _call
        self.await_args_list.append(_call)
    
        effect = self.side_effect
        if effect is not None:
            if _is_exception(effect):
&gt;               raise effect
E               Exception: Connection lost

/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py:2321: Exception

During handling of the above exception, another exception occurred:

self = &lt;test_realtime_api.TestErrorHandling object at 0x10ac71f90&gt;

    @pytest.mark.asyncio
    async def test_websocket_connection_failure_handling(self):
        """Test handling of WebSocket connection failures"""
        from services.websocket_manager import push_dialog_message
    
        # Create a mock WebSocket that always fails
        failing_ws = AsyncMock()
        failing_ws.send_json.side_effect = Exception("Connection lost")
    
        working_ws = AsyncMock()
    
        dialog_id = 123
        ws_connections[dialog_id] = [failing_ws, working_ws]
    
        message = {"id": 1, "text": "test"}
    
        # Should not raise exception
&gt;       await push_dialog_message(dialog_id, message)

tests/test_realtime_api.py:344: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
services/websocket_manager.py:509: in push_dialog_message
    await _drop_socket(ws_connections, ws_meta, dialog_id, ws, reason="Send failed")
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

bucket = {123: [&lt;AsyncMock id='4486724784'&gt;, &lt;AsyncMock id='4486721760'&gt;]}
meta_bucket = {}, dialog_id = 123, ws = &lt;AsyncMock id='4486724784'&gt;, code = 1001
reason = 'Send failed'

    async def _drop_socket(bucket: Dict[int, Set[WebSocket]], meta_bucket: Dict[int, Dict[WebSocket, Dict[str, float]]], dialog_id: int, ws: WebSocket, code=WSCloseCodes.GOING_AWAY, reason="Connection dropped"):
        """Безопасно удаляет сокет из всех структур данных"""
        global _total_connections
    
        conns = bucket.get(dialog_id, set())
        if ws in conns:
&gt;           conns.discard(ws)
            ^^^^^^^^^^^^^
E           AttributeError: 'list' object has no attribute 'discard'

services/websocket_manager.py:236: AttributeError</failure></testcase></testsuite></testsuites>